import * as S from '@effect/schema/Schema'
import { formatError } from '@effect/schema/TreeFormatter'
import { Effect as E, pipe } from 'effect'

const optional = <A>(s: S.Schema<A>) => S.optional(s, { exact: true })

export class ParsingError extends S.TaggedError<ParsingError>()('ParsingError', {
  message: S.String,
  detail: S.String,
}) {}

/* Components */

export const VerifyEmailLink = S.Struct({
  method: S.Literal('link'),
  redirectUrl: S.String
})

export type VerifyEmailLink = S.Schema.Type<typeof VerifyEmailLink>

export const VerifyEmailCode = S.Struct({
  method: S.Literal('code'),
})

export type VerifyEmailCode = S.Schema.Type<typeof VerifyEmailCode>

export const VerifyEmail = S.Union(VerifyEmailLink, VerifyEmailCode)

export type VerifyEmail = S.Schema.Type<typeof VerifyEmail>

const PublicKey = S.Literal('public-key')

const PubKeyCredParams = S.Struct({
  alg: S.Number,
  type: PublicKey,
})

const AuthenticatorAttachment = S.Union(S.Literal('cross-platform'), S.Literal('platform'))

const base64url = S.String

export const Transport = S.Union(
  S.Literal('ble'),
  S.Literal('hybrid'),
  S.Literal('internal'),
  S.Literal('nfc'),
  S.Literal('usb'),
)

const Credential = S.Struct({
  id: base64url,
  type: PublicKey,
  transports: optional(S.mutable(S.Array(Transport))),
})

export const UserVerification = S.Union(
  S.Literal('discouraged'),
  S.Literal('preferred'),
  S.Literal('required'),
)

export type UserVerification = S.Schema.Type<typeof UserVerification>

const ResidentKey = S.Union(S.Literal('discouraged'), S.Literal('preferred'), S.Literal('required'))

const AuthenticatorSelection = S.Struct({
  authenticatorAttachment: optional(AuthenticatorAttachment),
  requireResidentKey: optional(S.Boolean),
  residentKey: optional(ResidentKey),
  userVerification: optional(UserVerification),
})

export const AuthType = S.Literal('email', 'apple', 'google', 'passkey')

export type AuthType = S.Schema.Type<typeof AuthType>

/* Registration */

/**
 * Required by the browser to generate a passkey.
 * Wrap this into a publicKey and pass into createRequestFromJSON
 * i.e. createRequestFromJSON({ publicKey: RegistrationOptions })
 */
export const RegistrationOptions = S.Struct({
  rp: S.Struct({
    name: S.String,
    id: optional(base64url),
  }),
  user: S.Struct({
    id: base64url,
    name: S.String,
    displayName: S.String,
  }),
  challenge: base64url,
  pubKeyCredParams: S.mutable(S.Array(PubKeyCredParams)),
  timeout: optional(S.Number),
  excludeCredentials: optional(S.mutable(S.Array(Credential))),
  authenticatorSelection: optional(AuthenticatorSelection),
  attestation: optional(
    S.Union(S.Literal('direct'), S.Literal('enterprise'), S.Literal('indirect'), S.Literal('none')),
  ),
  extensions: optional(
    S.Struct({
      appid: optional(S.String),
      appidExclude: optional(S.String),
      credProps: optional(S.Boolean),
    }),
  ),
})

export type RegistrationOptions = S.Schema.Type<typeof RegistrationOptions>

/** Public key credential (generated by the browser) */
export const RegistrationCredential = S.Struct({
  id: S.String,
  type: PublicKey,
  rawId: S.String,
  authenticatorAttachment: S.optional(S.NullishOr(AuthenticatorAttachment)),
  response: S.Struct({
    clientDataJSON: S.String,
    attestationObject: S.String,
    transports: S.mutable(S.Array(Transport)),
  }),
  clientExtensionResults: S.Struct({
    appid: S.optional(S.Boolean),
    appidExclude: S.optional(S.Boolean),
    credProps: S.optional(S.Struct({ rk: S.Boolean })),
  }),
})

export type RegistrationCredential = S.Schema.Type<typeof RegistrationCredential>

/* Authentication */

export const AuthenticationOptions = S.Struct({
  challenge: S.String,
  timeout: optional(S.Number),
  rpId: optional(S.String),
  allowCredentials: optional(S.mutable(S.Array(Credential))),
  userVerification: optional(UserVerification),
  extensions: optional(
    S.Struct({
      appid: optional(S.String),
      credProps: optional(S.Boolean),
      hmacCreateSecret: optional(S.Boolean),
    }),
  ),
})

export type AuthenticationOptions = S.Schema.Type<typeof AuthenticationOptions>

/** Browser's response to the backend's auth challenge  */
export const AuthenticationCredential = S.Struct({
  id: S.String,
  type: PublicKey,
  rawId: S.String,
  authenticatorAttachment: S.optional(S.NullishOr(S.String)),
  response: S.Struct({
    clientDataJSON: S.String,
    authenticatorData: S.String,
    signature: S.String,
    userHandle: S.NullishOr(S.String),
  }),
  clientExtensionResults: S.Struct({
    appid: S.optional(S.Boolean),
    appidExclude: S.optional(S.Boolean),
    credProps: S.optional(
      S.Struct({
        rk: S.Boolean,
      }),
    ),
  }),
})

export type AuthenticationCredential = S.Schema.Type<typeof AuthenticationCredential>

/** Represents a successful registration/authentication */
export const Principal = S.Struct({
  token: S.String,
  user: S.Struct({
    id: S.String,
    givenName: S.String,
    familyName: S.String,
    email: S.String,
    emailVerified: S.Boolean,
  }),
  authStatement: S.Struct({
    authType: AuthType,
    userVerified: S.Boolean,
    authTimestamp: S.Date,
  }),
  expireAt: S.Date,
})

export type Principal = S.Schema.Type<typeof Principal>

export const AuthenticationRequired = S.Struct({
  requiredAuthType: AuthType,
})

/* Utils */

export const createParser =
  <A, E, R>(schema: S.Schema<A, E, R>) =>
  (input: unknown) =>
    pipe(
      S.decodeUnknown(schema)(input),
      E.flip,
      E.flatMap(formatError),
      E.map(detail => new ParsingError({ message: 'Unable to parse input', detail })),
      E.flip
    )
